import { __awaiter } from "tslib";
import { ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, Output } from '@angular/core';
import { dismissOnDestroyToken, fireOnInitToken } from './di';
import { SweetAlert2LoaderService } from './sweetalert2-loader.service';
/**
 * <swal> component. See the README.md for usage.
 *
 * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.
 * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled
 * to SweetAlert2, but also is type-safe even if both libraries do not evolve in sync.
 *
 * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,
 *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.
 *
 * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.
 *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.
 *     If you are really concerned about performance and/or don't care about the API and its convenient integration
 *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)
 *
 * /!\ Some SweetAlert options aren't @Inputs but @Outputs: `willOpen`, `didOpen`, `didRender`, `willClose`, `didClose`
 *     and `didDestroy`.
 *     However, `preConfirm`, `preDeny` and `inputValidator` are still @Inputs because they are not event handlers,
 *     there can't be multiple listeners on them, and we need the values they can/must return.
 */
import * as ɵngcc0 from '@angular/core';
export class SwalComponent {
    constructor(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {
        this.sweetAlert2Loader = sweetAlert2Loader;
        this.moduleLevelFireOnInit = moduleLevelFireOnInit;
        this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;
        /**
         * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.
         */
        this.willOpen = new EventEmitter();
        /**
         * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.
         */
        this.didOpen = new EventEmitter();
        /**
         * Modal lifecycle hook. Synchronously runs after the popup DOM has been updated (ie. just before the modal is
         * repainted on the screen).
         * Typically, this will happen after `Swal.fire()` or `Swal.update()`.
         * If you want to perform changes in the popup's DOM, that survive `Swal.update()`, prefer {@link didRender} over
         * {@link willOpen}.
         */
        this.didRender = new EventEmitter();
        /**
         * Modal lifecycle hook. Synchronously runs when the popup closes by user interaction (and not due to another popup
         * being fired).
         */
        this.willClose = new EventEmitter();
        /**
         * Modal lifecycle hook. Asynchronously runs after the popup has been disposed by user interaction (and not due to
         * another popup being fired).
         */
        this.didClose = new EventEmitter();
        /**
         * Modal lifecycle hook. Synchronously runs after popup has been destroyed either by user interaction or by another
         * popup.
         * If you have cleanup operations that you need to reliably execute each time a modal is closed, prefer
         * {@link didDestroy} over {@link didClose}.
         */
        this.didDestroy = new EventEmitter();
        /**
         * Emits when the user clicks "Confirm".
         * The event value ($event) can be either:
         *  - by default, just `true`,
         *  - when using {@link input}, the input value,
         *  - when using {@link preConfirm}, the return value of this function.
         *
         * Example:
         *     <swal (confirm)="handleConfirm($event)"></swal>
         *
         *     public handleConfirm(email: string): void {
         *         // ... save user email
         *     }
         */
        this.confirm = new EventEmitter();
        /**
         * Emits when the user clicks "Deny".
         * This event bears no value.
         * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and
         * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.
         *
         * Example:
         *     <swal (deny)="handleDeny()"></swal>
         *
         *     public handleDeny(): void {
         *     }
         */
        this.deny = new EventEmitter();
        /**
         * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
         * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when
         * the modal was programmatically closed (through {@link close} for example).
         *
         * Example:
         *     <swal (dismiss)="handleDismiss($event)"></swal>
         *
         *     public handleDismiss(reason: DismissReason | undefined): void {
         *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
         *         // ... do something
         *     }
         */
        this.dismiss = new EventEmitter();
        /**
         * This Set retains the properties that have been changed from @Inputs, so we can know precisely
         * what options we have to send to {@link Swal.fire}.
         */
        this.touchedProps = new Set();
        /**
         * A function of signature `(propName: string): void` that adds a given property name to the list of
         * touched properties, ie. {@link touchedProps}.
         */
        this.markTouched = this.touchedProps.add.bind(this.touchedProps);
        /**
         * Is the SweetAlert2 modal represented by this component currently opened?
         */
        this.isCurrentlyShown = false;
    }
    /**
     * An object of SweetAlert2 native options, useful if:
     *  - you don't want to use the @Inputs for practical/philosophical reasons ;
     *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.
     *
     * /!\ Please note that setting this property does NOT erase what has been set before unless you specify the
     *     previous properties you want to erase again.
     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.
     *
     * /!\ Be aware that the options defined in this object will override the @Inputs of the same name.
     */
    set swalOptions(options) {
        //=> Update properties
        Object.assign(this, options);
        //=> Mark changed properties as touched
        const touchedKeys = Object.keys(options);
        touchedKeys.forEach(this.markTouched);
    }
    /**
     * Computes the options object that will get passed to SweetAlert2.
     * Only the properties that have been set at least once on this component will be returned.
     * Mostly for internal usage.
     */
    get swalOptions() {
        //=> We will compute the options object based on the option keys that are known to have changed.
        //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially
        //   avoiding side effects.
        return [...this.touchedProps].reduce((obj, key) => (Object.assign(Object.assign({}, obj), { [key]: this[key] })), {});
    }
    set swalVisible(visible) {
        visible ? this.fire() : this.close();
    }
    get swalVisible() {
        return this.isCurrentlyShown;
    }
    /**
     * Angular lifecycle hook.
     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there
     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,
     * causing no delay.
     */
    ngOnInit() {
        //=> Preload SweetAlert2 library in case this component is activated.
        this.sweetAlert2Loader.preloadSweetAlertLibrary();
    }
    /**
     * Angular lifecycle hook.
     * Fires the modal, if the component or module is configured to do so.
     */
    ngAfterViewInit() {
        const fireOnInit = this.swalFireOnInit === undefined
            ? this.moduleLevelFireOnInit
            : this.swalFireOnInit;
        fireOnInit && this.fire();
    }
    /**
     * Angular lifecycle hook.
     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.
     */
    ngOnChanges(changes) {
        //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can
        //   send it with the next fire() or update() calls.
        Object.keys(changes)
            //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter
            .filter((key) => !key.startsWith('swal'))
            .forEach(this.markTouched);
        //=> Eventually trigger re-render if the modal is open.
        void this.update();
    }
    /**
     * Angular lifecycle hook.
     * Closes the SweetAlert when the component is destroyed.
     */
    ngOnDestroy() {
        //=> Release the modal if the component is destroyed and if that behaviour is not disabled.
        const dismissOnDestroy = this.swalDismissOnDestroy === undefined
            ? this.moduleLevelDismissOnDestroy
            : this.swalDismissOnDestroy;
        dismissOnDestroy && this.close();
    }
    /**
     * Shows the SweetAlert.
     *
     * Returns the SweetAlert2 promise for convenience and use in code behind templates.
     * Otherwise, (confirm)="myHandler($event)" and (dismiss)="myHandler($event)" can be used in templates.
     */
    fire() {
        return __awaiter(this, void 0, void 0, function* () {
            const swal = yield this.sweetAlert2Loader.swal;
            const userOptions = this.swalOptions;
            //=> Build the SweetAlert2 options
            const options = Object.assign(Object.assign({}, userOptions), { 
                //=> Handle modal lifecycle events
                willOpen: composeHook(userOptions.willOpen, (modalElement) => {
                    this.willOpen.emit({ modalElement });
                }), didOpen: composeHook(userOptions.didOpen, (modalElement) => {
                    this.isCurrentlyShown = true;
                    this.didOpen.emit({ modalElement });
                }), didRender: composeHook(userOptions.didRender, (modalElement) => {
                    this.didRender.emit({ modalElement });
                }), willClose: composeHook(userOptions.willClose, (modalElement) => {
                    this.isCurrentlyShown = false;
                    this.willClose.emit({ modalElement });
                }), didClose: composeHook(userOptions.didClose, () => {
                    this.didClose.emit();
                }), didDestroy: composeHook(userOptions.didDestroy, () => {
                    this.didDestroy.emit();
                }) });
            //=> Show the Swal! And wait for confirmation or dimissal.
            const result = yield swal.fire(options);
            //=> Emit on (confirm), (deny) or (dismiss)
            switch (true) {
                case result.isConfirmed:
                    this.confirm.emit(result.value);
                    break;
                case result.isDenied:
                    this.deny.emit();
                    break;
                case result.isDismissed:
                    this.dismiss.emit(result.dismiss);
                    break;
            }
            return result;
            function composeHook(userHook, libHook) {
                return (...args) => (libHook(...args), userHook === null || userHook === void 0 ? void 0 : userHook(...args));
            }
        });
    }
    /**
     * Closes the modal, if opened.
     *
     * @param result The value that the modal will resolve with, triggering either (confirm), (deny) or (dismiss).
     *               If the argument is not passed, it is (dismiss) that will emit an `undefined` reason.
     *               {@see Swal.close}.
     */
    close(result) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isCurrentlyShown)
                return;
            const swal = yield this.sweetAlert2Loader.swal;
            swal.close(result);
        });
    }
    /**
     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.
     * If the modal is not opened, the component options will simply be updated and that's it.
     *
     * /!\ Please note that not all SweetAlert2 options are updatable while the modal is opened.
     *
     * @param options
     */
    update(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options) {
                this.swalOptions = options;
            }
            if (!this.isCurrentlyShown)
                return;
            const swal = yield this.sweetAlert2Loader.swal;
            const allOptions = this.swalOptions;
            const updatableOptions = Object.keys(allOptions)
                .filter(swal.isUpdatableParameter)
                .reduce((obj, key) => (Object.assign(Object.assign({}, obj), { [key]: allOptions[key] })), {});
            swal.update(updatableOptions);
        });
    }
}
SwalComponent.ɵfac = function SwalComponent_Factory(t) { return new (t || SwalComponent)(ɵngcc0.ɵɵdirectiveInject(SweetAlert2LoaderService), ɵngcc0.ɵɵdirectiveInject(fireOnInitToken), ɵngcc0.ɵɵdirectiveInject(dismissOnDestroyToken)); };
SwalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SwalComponent, selectors: [["swal"]], inputs: { swalOptions: "swalOptions", swalVisible: "swalVisible", title: "title", titleText: "titleText", text: "text", html: "html", footer: "footer", icon: "icon", iconColor: "iconColor", iconHtml: "iconHtml", backdrop: "backdrop", toast: "toast", target: "target", input: "input", width: "width", padding: "padding", background: "background", position: "position", grow: "grow", showClass: "showClass", hideClass: "hideClass", customClass: "customClass", timer: "timer", timerProgressBar: "timerProgressBar", animation: "animation", heightAuto: "heightAuto", allowOutsideClick: "allowOutsideClick", allowEscapeKey: "allowEscapeKey", allowEnterKey: "allowEnterKey", stopKeydownPropagation: "stopKeydownPropagation", keydownListenerCapture: "keydownListenerCapture", showConfirmButton: "showConfirmButton", showDenyButton: "showDenyButton", showCancelButton: "showCancelButton", confirmButtonText: "confirmButtonText", denyButtonText: "denyButtonText", cancelButtonText: "cancelButtonText", confirmButtonColor: "confirmButtonColor", denyButtonColor: "denyButtonColor", cancelButtonColor: "cancelButtonColor", confirmButtonAriaLabel: "confirmButtonAriaLabel", denyButtonAriaLabel: "denyButtonAriaLabel", cancelButtonAriaLabel: "cancelButtonAriaLabel", buttonsStyling: "buttonsStyling", reverseButtons: "reverseButtons", focusConfirm: "focusConfirm", focusDeny: "focusDeny", focusCancel: "focusCancel", showCloseButton: "showCloseButton", closeButtonHtml: "closeButtonHtml", closeButtonAriaLabel: "closeButtonAriaLabel", loaderHtml: "loaderHtml", showLoaderOnConfirm: "showLoaderOnConfirm", preConfirm: "preConfirm", preDeny: "preDeny", imageUrl: "imageUrl", imageWidth: "imageWidth", imageHeight: "imageHeight", imageAlt: "imageAlt", inputLabel: "inputLabel", inputPlaceholder: "inputPlaceholder", inputValue: "inputValue", inputOptions: "inputOptions", inputAutoTrim: "inputAutoTrim", inputAttributes: "inputAttributes", inputValidator: "inputValidator", returnInputValueOnDeny: "returnInputValueOnDeny", validationMessage: "validationMessage", progressSteps: "progressSteps", currentProgressStep: "currentProgressStep", progressStepsDistance: "progressStepsDistance", scrollbarPadding: "scrollbarPadding", swalFireOnInit: "swalFireOnInit", swalDismissOnDestroy: "swalDismissOnDestroy" }, outputs: { willOpen: "willOpen", didOpen: "didOpen", didRender: "didRender", willClose: "willClose", didClose: "didClose", didDestroy: "didDestroy", confirm: "confirm", deny: "deny", dismiss: "dismiss" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function SwalComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SwalComponent.ctorParameters = () => [
    { type: SweetAlert2LoaderService },
    { type: Boolean, decorators: [{ type: Inject, args: [fireOnInitToken,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [dismissOnDestroyToken,] }] }
];
SwalComponent.propDecorators = {
    title: [{ type: Input }],
    titleText: [{ type: Input }],
    text: [{ type: Input }],
    html: [{ type: Input }],
    footer: [{ type: Input }],
    icon: [{ type: Input }],
    iconColor: [{ type: Input }],
    iconHtml: [{ type: Input }],
    backdrop: [{ type: Input }],
    toast: [{ type: Input }],
    target: [{ type: Input }],
    input: [{ type: Input }],
    width: [{ type: Input }],
    padding: [{ type: Input }],
    background: [{ type: Input }],
    position: [{ type: Input }],
    grow: [{ type: Input }],
    showClass: [{ type: Input }],
    hideClass: [{ type: Input }],
    customClass: [{ type: Input }],
    timer: [{ type: Input }],
    timerProgressBar: [{ type: Input }],
    animation: [{ type: Input }],
    heightAuto: [{ type: Input }],
    allowOutsideClick: [{ type: Input }],
    allowEscapeKey: [{ type: Input }],
    allowEnterKey: [{ type: Input }],
    stopKeydownPropagation: [{ type: Input }],
    keydownListenerCapture: [{ type: Input }],
    showConfirmButton: [{ type: Input }],
    showDenyButton: [{ type: Input }],
    showCancelButton: [{ type: Input }],
    confirmButtonText: [{ type: Input }],
    denyButtonText: [{ type: Input }],
    cancelButtonText: [{ type: Input }],
    confirmButtonColor: [{ type: Input }],
    denyButtonColor: [{ type: Input }],
    cancelButtonColor: [{ type: Input }],
    confirmButtonAriaLabel: [{ type: Input }],
    denyButtonAriaLabel: [{ type: Input }],
    cancelButtonAriaLabel: [{ type: Input }],
    buttonsStyling: [{ type: Input }],
    reverseButtons: [{ type: Input }],
    focusConfirm: [{ type: Input }],
    focusDeny: [{ type: Input }],
    focusCancel: [{ type: Input }],
    showCloseButton: [{ type: Input }],
    closeButtonHtml: [{ type: Input }],
    closeButtonAriaLabel: [{ type: Input }],
    loaderHtml: [{ type: Input }],
    showLoaderOnConfirm: [{ type: Input }],
    preConfirm: [{ type: Input }],
    preDeny: [{ type: Input }],
    imageUrl: [{ type: Input }],
    imageWidth: [{ type: Input }],
    imageHeight: [{ type: Input }],
    imageAlt: [{ type: Input }],
    inputLabel: [{ type: Input }],
    inputPlaceholder: [{ type: Input }],
    inputValue: [{ type: Input }],
    inputOptions: [{ type: Input }],
    inputAutoTrim: [{ type: Input }],
    inputAttributes: [{ type: Input }],
    inputValidator: [{ type: Input }],
    returnInputValueOnDeny: [{ type: Input }],
    validationMessage: [{ type: Input }],
    progressSteps: [{ type: Input }],
    currentProgressStep: [{ type: Input }],
    progressStepsDistance: [{ type: Input }],
    scrollbarPadding: [{ type: Input }],
    swalOptions: [{ type: Input }],
    swalFireOnInit: [{ type: Input }],
    swalDismissOnDestroy: [{ type: Input }],
    swalVisible: [{ type: Input }],
    willOpen: [{ type: Output }],
    didOpen: [{ type: Output }],
    didRender: [{ type: Output }],
    willClose: [{ type: Output }],
    didClose: [{ type: Output }],
    didDestroy: [{ type: Output }],
    confirm: [{ type: Output }],
    deny: [{ type: Output }],
    dismiss: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SwalComponent, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:component-selector
                selector: 'swal',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: SweetAlert2LoaderService }, { type: Boolean, decorators: [{
                type: Inject,
                args: [fireOnInitToken]
            }] }, { type: Boolean, decorators: [{
                type: Inject,
                args: [dismissOnDestroyToken]
            }] }]; }, { willOpen: [{
            type: Output
        }], didOpen: [{
            type: Output
        }], didRender: [{
            type: Output
        }], willClose: [{
            type: Output
        }], didClose: [{
            type: Output
        }], didDestroy: [{
            type: Output
        }], confirm: [{
            type: Output
        }], deny: [{
            type: Output
        }], dismiss: [{
            type: Output
        }], swalOptions: [{
            type: Input
        }], swalVisible: [{
            type: Input
        }], title: [{
            type: Input
        }], titleText: [{
            type: Input
        }], text: [{
            type: Input
        }], html: [{
            type: Input
        }], footer: [{
            type: Input
        }], icon: [{
            type: Input
        }], iconColor: [{
            type: Input
        }], iconHtml: [{
            type: Input
        }], backdrop: [{
            type: Input
        }], toast: [{
            type: Input
        }], target: [{
            type: Input
        }], input: [{
            type: Input
        }], width: [{
            type: Input
        }], padding: [{
            type: Input
        }], background: [{
            type: Input
        }], position: [{
            type: Input
        }], grow: [{
            type: Input
        }], showClass: [{
            type: Input
        }], hideClass: [{
            type: Input
        }], customClass: [{
            type: Input
        }], timer: [{
            type: Input
        }], timerProgressBar: [{
            type: Input
        }], animation: [{
            type: Input
        }], heightAuto: [{
            type: Input
        }], allowOutsideClick: [{
            type: Input
        }], allowEscapeKey: [{
            type: Input
        }], allowEnterKey: [{
            type: Input
        }], stopKeydownPropagation: [{
            type: Input
        }], keydownListenerCapture: [{
            type: Input
        }], showConfirmButton: [{
            type: Input
        }], showDenyButton: [{
            type: Input
        }], showCancelButton: [{
            type: Input
        }], confirmButtonText: [{
            type: Input
        }], denyButtonText: [{
            type: Input
        }], cancelButtonText: [{
            type: Input
        }], confirmButtonColor: [{
            type: Input
        }], denyButtonColor: [{
            type: Input
        }], cancelButtonColor: [{
            type: Input
        }], confirmButtonAriaLabel: [{
            type: Input
        }], denyButtonAriaLabel: [{
            type: Input
        }], cancelButtonAriaLabel: [{
            type: Input
        }], buttonsStyling: [{
            type: Input
        }], reverseButtons: [{
            type: Input
        }], focusConfirm: [{
            type: Input
        }], focusDeny: [{
            type: Input
        }], focusCancel: [{
            type: Input
        }], showCloseButton: [{
            type: Input
        }], closeButtonHtml: [{
            type: Input
        }], closeButtonAriaLabel: [{
            type: Input
        }], loaderHtml: [{
            type: Input
        }], showLoaderOnConfirm: [{
            type: Input
        }], preConfirm: [{
            type: Input
        }], preDeny: [{
            type: Input
        }], imageUrl: [{
            type: Input
        }], imageWidth: [{
            type: Input
        }], imageHeight: [{
            type: Input
        }], imageAlt: [{
            type: Input
        }], inputLabel: [{
            type: Input
        }], inputPlaceholder: [{
            type: Input
        }], inputValue: [{
            type: Input
        }], inputOptions: [{
            type: Input
        }], inputAutoTrim: [{
            type: Input
        }], inputAttributes: [{
            type: Input
        }], inputValidator: [{
            type: Input
        }], returnInputValueOnDeny: [{
            type: Input
        }], validationMessage: [{
            type: Input
        }], progressSteps: [{
            type: Input
        }], currentProgressStep: [{
            type: Input
        }], progressStepsDistance: [{
            type: Input
        }], scrollbarPadding: [{
            type: Input
        }], swalFireOnInit: [{
            type: Input
        }], swalDismissOnDestroy: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Byb2plY3RzL25neC1zd2VldGFsZXJ0Mi9zcmMvbGliL3N3YWwuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ1ksdUJBQXVCLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUM5RSxNQUFNLEVBQ1QsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLGVBQWUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUU5RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBT0gsTUFBTSxPQUFPLGFBQWE7QUFBRyxJQW9QekIsWUFDcUIsaUJBQTJDLEVBQ2xCLHFCQUE4QixFQUN4QiwyQkFBb0M7QUFDNUYsUUFIeUIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUEwQjtBQUFDLFFBQ25CLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBUztBQUFDLFFBQ3pCLGdDQUEyQixHQUEzQiwyQkFBMkIsQ0FBUztBQUFDLFFBakh6RjtBQUNKO0FBQ0ksV0FBRztBQUNQLFFBQ29CLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBd0IsQ0FBQztBQUN4RSxRQUNJO0FBQ0o7QUFDSSxXQUFHO0FBQ1AsUUFDb0IsWUFBTyxHQUFHLElBQUksWUFBWSxFQUF1QixDQUFDO0FBQ3RFLFFBQ0k7QUFDSjtBQUNJO0FBQ0k7QUFDSTtBQUNJO0FBRUosV0FETDtBQUNQLFFBQ29CLGNBQVMsR0FBRyxJQUFJLFlBQVksRUFBeUIsQ0FBQztBQUMxRSxRQUNJO0FBQ0o7QUFDSTtBQUVKLFdBRE87QUFDUCxRQUNvQixjQUFTLEdBQUcsSUFBSSxZ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QkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEluamVjdCwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsXG4gICAgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IFN3YWwsIHsgU3dlZXRBbGVydE9wdGlvbnMsIFN3ZWV0QWxlcnRSZXN1bHQsIFN3ZWV0QWxlcnRVcGRhdGFibGVQYXJhbWV0ZXJzIH0gZnJvbSAnc3dlZXRhbGVydDInO1xuaW1wb3J0IHsgZGlzbWlzc09uRGVzdHJveVRva2VuLCBmaXJlT25Jbml0VG9rZW4gfSBmcm9tICcuL2RpJztcbmltcG9ydCAqIGFzIGV2ZW50cyBmcm9tICcuL3N3YWwtZXZlbnRzJztcbmltcG9ydCB7IFN3ZWV0QWxlcnQyTG9hZGVyU2VydmljZSB9IGZyb20gJy4vc3dlZXRhbGVydDItbG9hZGVyLnNlcnZpY2UnO1xuXG4vKipcbiAqIDxzd2FsPiBjb21wb25lbnQuIFNlZSB0aGUgUkVBRE1FLm1kIGZvciB1c2FnZS5cbiAqXG4gKiBJdCBjb250YWlucyBhIGJ1bmNoIG9mIEBJbnB1dHMgdGhhdCBoYXZlIGEgcGVyZmVjdCAxOjEgbWFwcGluZyB3aXRoIFN3ZWV0QWxlcnQyIG9wdGlvbnMuXG4gKiBUaGVpciB0eXBlcyBhcmUgZGlyZWN0bHkgY29taW5nIGZyb20gU3dlZXRBbGVydDIgdHlwZXMgZGVmaW50aXRpb25zLCBtZWFuaW5nIHRoYXQgbmd4LXN3ZWV0YWxlcnQyIGlzIHRpZ2h0bHkgY291cGxlZFxuICogdG8gU3dlZXRBbGVydDIsIGJ1dCBhbHNvIGlzIHR5cGUtc2FmZSBldmVuIGlmIGJvdGggbGlicmFyaWVzIGRvIG5vdCBldm9sdmUgaW4gc3luYy5cbiAqXG4gKiAoPykgSWYgeW91IHdhbnQgdG8gdXNlIGFuIG9iamVjdCB0aGF0IGRlY2xhcmVzIHRoZSBTd2VldEFsZXJ0MiBvcHRpb25zIGFsbCBhdCBvbmNlIHJhdGhlciB0aGFuIG1hbnkgQElucHV0cyxcbiAqICAgICB0YWtlIGEgbG9vayBhdCBbc3dhbE9wdGlvbnNdLCB0aGF0IGxldHMgeW91IHBhc3MgYSBmdWxsIHtAbGluayBTd2VldEFsZXJ0T3B0aW9uc30gb2JqZWN0LlxuICpcbiAqICg/KSBJZiB5b3UgYXJlIHJlYWRpbmcgdGhlIFR5cGVTY3JpcHQgc291cmNlIG9mIHRoaXMgY29tcG9uZW50LCB5b3UgbWF5IHRoaW5rIHRoYXQgaXQncyBhIGxvdCBvZiBjb2RlLlxuICogICAgIEJlIHN1cmUgdGhhdCBhIGxvdCBvZiB0aGlzIGNvZGUgaXMgdHlwZXMgYW5kIEFuZ3VsYXIgYm9pbGVycGxhdGUuIENvbXBpbGVkIGFuZCBtaW5pZmllZCBjb2RlIGlzIG11Y2ggc21hbGxlci5cbiAqICAgICBJZiB5b3UgYXJlIHJlYWxseSBjb25jZXJuZWQgYWJvdXQgcGVyZm9ybWFuY2UgYW5kL29yIGRvbid0IGNhcmUgYWJvdXQgdGhlIEFQSSBhbmQgaXRzIGNvbnZlbmllbnQgaW50ZWdyYXRpb25cbiAqICAgICB3aXRoIEFuZ3VsYXIgKG5vdGFibHkgY2hhbmdlIGRldGVjdGlvbiBhbmQgdHJhbnNjbHVzaW9uKSwgeW91IG1heSB0b3RhbGx5IHVzZSBTd2VldEFsZXJ0MiBuYXRpdmVseSBhcyB3ZWxsIDspXG4gKlxuICogLyFcXCBTb21lIFN3ZWV0QWxlcnQgb3B0aW9ucyBhcmVuJ3QgQElucHV0cyBidXQgQE91dHB1dHM6IGB3aWxsT3BlbmAsIGBkaWRPcGVuYCwgYGRpZFJlbmRlcmAsIGB3aWxsQ2xvc2VgLCBgZGlkQ2xvc2VgXG4gKiAgICAgYW5kIGBkaWREZXN0cm95YC5cbiAqICAgICBIb3dldmVyLCBgcHJlQ29uZmlybWAsIGBwcmVEZW55YCBhbmQgYGlucHV0VmFsaWRhdG9yYCBhcmUgc3RpbGwgQElucHV0cyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBldmVudCBoYW5kbGVycyxcbiAqICAgICB0aGVyZSBjYW4ndCBiZSBtdWx0aXBsZSBsaXN0ZW5lcnMgb24gdGhlbSwgYW5kIHdlIG5lZWQgdGhlIHZhbHVlcyB0aGV5IGNhbi9tdXN0IHJldHVybi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNvbXBvbmVudC1zZWxlY3RvclxuICAgIHNlbGVjdG9yOiAnc3dhbCcsXG4gICAgdGVtcGxhdGU6ICcnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFN3YWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGl0bGU6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aXRsZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0aXRsZVRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0aXRsZVRleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ3RleHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2h0bWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9vdGVyOiBTd2VldEFsZXJ0T3B0aW9uc1snZm9vdGVyJ107XG4gICAgQElucHV0KCkgcHVibGljIGljb246IFN3ZWV0QWxlcnRPcHRpb25zWydpY29uJ107XG4gICAgQElucHV0KCkgcHVibGljIGljb25Db2xvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2ljb25Db2xvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpY29uSHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2ljb25IdG1sJ107XG4gICAgQElucHV0KCkgcHVibGljIGJhY2tkcm9wOiBTd2VldEFsZXJ0T3B0aW9uc1snYmFja2Ryb3AnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdG9hc3Q6IFN3ZWV0QWxlcnRPcHRpb25zWyd0b2FzdCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB0YXJnZXQ6IFN3ZWV0QWxlcnRPcHRpb25zWyd0YXJnZXQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXQ6IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyB3aWR0aDogU3dlZXRBbGVydE9wdGlvbnNbJ3dpZHRoJ107XG4gICAgQElucHV0KCkgcHVibGljIHBhZGRpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydwYWRkaW5nJ107XG4gICAgQElucHV0KCkgcHVibGljIGJhY2tncm91bmQ6IFN3ZWV0QWxlcnRPcHRpb25zWydiYWNrZ3JvdW5kJ107XG4gICAgQElucHV0KCkgcHVibGljIHBvc2l0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1sncG9zaXRpb24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZ3JvdzogU3dlZXRBbGVydE9wdGlvbnNbJ2dyb3cnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0NsYXNzOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0NsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIGhpZGVDbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2hpZGVDbGFzcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjdXN0b21DbGFzczogU3dlZXRBbGVydE9wdGlvbnNbJ2N1c3RvbUNsYXNzJ107XG4gICAgQElucHV0KCkgcHVibGljIHRpbWVyOiBTd2VldEFsZXJ0T3B0aW9uc1sndGltZXInXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgdGltZXJQcm9ncmVzc0JhcjogU3dlZXRBbGVydE9wdGlvbnNbJ3RpbWVyUHJvZ3Jlc3NCYXInXTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIHNob3dDbGFzcyBhbmQgaGlkZUNsYXNzIGluc3RlYWQgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgYW5pbWF0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1snYW5pbWF0aW9uJ107XG4gICAgQElucHV0KCkgcHVibGljIGhlaWdodEF1dG86IFN3ZWV0QWxlcnRPcHRpb25zWydoZWlnaHRBdXRvJ107XG4gICAgQElucHV0KCkgcHVibGljIGFsbG93T3V0c2lkZUNsaWNrOiBTd2VldEFsZXJ0T3B0aW9uc1snYWxsb3dPdXRzaWRlQ2xpY2snXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYWxsb3dFc2NhcGVLZXk6IFN3ZWV0QWxlcnRPcHRpb25zWydhbGxvd0VzY2FwZUtleSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBhbGxvd0VudGVyS2V5OiBTd2VldEFsZXJ0T3B0aW9uc1snYWxsb3dFbnRlcktleSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzdG9wS2V5ZG93blByb3BhZ2F0aW9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc3RvcEtleWRvd25Qcm9wYWdhdGlvbiddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBrZXlkb3duTGlzdGVuZXJDYXB0dXJlOiBTd2VldEFsZXJ0T3B0aW9uc1sna2V5ZG93bkxpc3RlbmVyQ2FwdHVyZSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93Q29uZmlybUJ1dHRvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDb25maXJtQnV0dG9uJ107XG4gICAgQElucHV0KCkgcHVibGljIHNob3dEZW55QnV0dG9uOiBTd2VldEFsZXJ0T3B0aW9uc1snc2hvd0RlbnlCdXR0b24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0NhbmNlbEJ1dHRvbjogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dDYW5jZWxCdXR0b24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY29uZmlybUJ1dHRvblRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydjb25maXJtQnV0dG9uVGV4dCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBkZW55QnV0dG9uVGV4dDogU3dlZXRBbGVydE9wdGlvbnNbJ2RlbnlCdXR0b25UZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIGNhbmNlbEJ1dHRvblRleHQ6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25UZXh0J107XG4gICAgQElucHV0KCkgcHVibGljIGNvbmZpcm1CdXR0b25Db2xvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2NvbmZpcm1CdXR0b25Db2xvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBkZW55QnV0dG9uQ29sb3I6IFN3ZWV0QWxlcnRPcHRpb25zWydkZW55QnV0dG9uQ29sb3InXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2FuY2VsQnV0dG9uQ29sb3I6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25Db2xvciddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjb25maXJtQnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snY29uZmlybUJ1dHRvbkFyaWFMYWJlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBkZW55QnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snZGVueUJ1dHRvbkFyaWFMYWJlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBjYW5jZWxCdXR0b25BcmlhTGFiZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydjYW5jZWxCdXR0b25BcmlhTGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgYnV0dG9uc1N0eWxpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydidXR0b25zU3R5bGluZyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyByZXZlcnNlQnV0dG9uczogU3dlZXRBbGVydE9wdGlvbnNbJ3JldmVyc2VCdXR0b25zJ107XG4gICAgQElucHV0KCkgcHVibGljIGZvY3VzQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ2ZvY3VzQ29uZmlybSddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBmb2N1c0Rlbnk6IFN3ZWV0QWxlcnRPcHRpb25zWydmb2N1c0RlbnknXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgZm9jdXNDYW5jZWw6IFN3ZWV0QWxlcnRPcHRpb25zWydmb2N1c0NhbmNlbCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBzaG93Q2xvc2VCdXR0b246IFN3ZWV0QWxlcnRPcHRpb25zWydzaG93Q2xvc2VCdXR0b24nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY2xvc2VCdXR0b25IdG1sOiBTd2VldEFsZXJ0T3B0aW9uc1snY2xvc2VCdXR0b25IdG1sJ107XG4gICAgQElucHV0KCkgcHVibGljIGNsb3NlQnV0dG9uQXJpYUxhYmVsOiBTd2VldEFsZXJ0T3B0aW9uc1snY2xvc2VCdXR0b25BcmlhTGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgbG9hZGVySHRtbDogU3dlZXRBbGVydE9wdGlvbnNbJ2xvYWRlckh0bWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgc2hvd0xvYWRlck9uQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ3Nob3dMb2FkZXJPbkNvbmZpcm0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcHJlQ29uZmlybTogU3dlZXRBbGVydE9wdGlvbnNbJ3ByZUNvbmZpcm0nXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcHJlRGVueTogU3dlZXRBbGVydE9wdGlvbnNbJ3ByZURlbnknXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW1hZ2VVcmw6IFN3ZWV0QWxlcnRPcHRpb25zWydpbWFnZVVybCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZVdpZHRoOiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VXaWR0aCddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbWFnZUhlaWdodDogU3dlZXRBbGVydE9wdGlvbnNbJ2ltYWdlSGVpZ2h0J107XG4gICAgQElucHV0KCkgcHVibGljIGltYWdlQWx0OiBTd2VldEFsZXJ0T3B0aW9uc1snaW1hZ2VBbHQnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRMYWJlbDogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0TGFiZWwnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRQbGFjZWhvbGRlcjogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0UGxhY2Vob2xkZXInXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRWYWx1ZTogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsdWUnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgaW5wdXRPcHRpb25zOiBTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRPcHRpb25zJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0QXV0b1RyaW06IFN3ZWV0QWxlcnRPcHRpb25zWydpbnB1dEF1dG9UcmltJ107XG4gICAgQElucHV0KCkgcHVibGljIGlucHV0QXR0cmlidXRlczogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0QXR0cmlidXRlcyddO1xuICAgIEBJbnB1dCgpIHB1YmxpYyBpbnB1dFZhbGlkYXRvcjogU3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsaWRhdG9yJ107XG4gICAgQElucHV0KCkgcHVibGljIHJldHVybklucHV0VmFsdWVPbkRlbnk6IFN3ZWV0QWxlcnRPcHRpb25zWydyZXR1cm5JbnB1dFZhbHVlT25EZW55J107XG4gICAgQElucHV0KCkgcHVibGljIHZhbGlkYXRpb25NZXNzYWdlOiBTd2VldEFsZXJ0T3B0aW9uc1sndmFsaWRhdGlvbk1lc3NhZ2UnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcHJvZ3Jlc3NTdGVwczogU3dlZXRBbGVydE9wdGlvbnNbJ3Byb2dyZXNzU3RlcHMnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgY3VycmVudFByb2dyZXNzU3RlcDogU3dlZXRBbGVydE9wdGlvbnNbJ2N1cnJlbnRQcm9ncmVzc1N0ZXAnXTtcbiAgICBASW5wdXQoKSBwdWJsaWMgcHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlOiBTd2VldEFsZXJ0T3B0aW9uc1sncHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlJ107XG4gICAgQElucHV0KCkgcHVibGljIHNjcm9sbGJhclBhZGRpbmc6IFN3ZWV0QWxlcnRPcHRpb25zWydzY3JvbGxiYXJQYWRkaW5nJ107XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3Qgb2YgU3dlZXRBbGVydDIgbmF0aXZlIG9wdGlvbnMsIHVzZWZ1bCBpZjpcbiAgICAgKiAgLSB5b3UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIEBJbnB1dHMgZm9yIHByYWN0aWNhbC9waGlsb3NvcGhpY2FsIHJlYXNvbnMgO1xuICAgICAqICAtIHRoZXJlIGFyZSBtaXNzaW5nIEBJbnB1dHMgYmVjYXVzZSBuZ3gtc3dlZXRhbGVydDIgaXNuJ3QgdXAtdG8tZGF0ZSB3aXRoIFN3ZWV0QWxlcnQyJ3MgbGF0ZXN0IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiAvIVxcIFBsZWFzZSBub3RlIHRoYXQgc2V0dGluZyB0aGlzIHByb3BlcnR5IGRvZXMgTk9UIGVyYXNlIHdoYXQgaGFzIGJlZW4gc2V0IGJlZm9yZSB1bmxlc3MgeW91IHNwZWNpZnkgdGhlXG4gICAgICogICAgIHByZXZpb3VzIHByb3BlcnRpZXMgeW91IHdhbnQgdG8gZXJhc2UgYWdhaW4uXG4gICAgICogICAgIEllLiBzZXR0aW5nIHsgdGl0bGU6ICdUaXRsZScgfSBhbmQgdGhlbiB7IHRleHQ6ICdUZXh0JyB9IHdpbGwgZ2l2ZSB7IHRpdGxlOiAnVGl0bGUnLCB0ZXh0OiAnVGV4dCcgfS5cbiAgICAgKlxuICAgICAqIC8hXFwgQmUgYXdhcmUgdGhhdCB0aGUgb3B0aW9ucyBkZWZpbmVkIGluIHRoaXMgb2JqZWN0IHdpbGwgb3ZlcnJpZGUgdGhlIEBJbnB1dHMgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgc3dhbE9wdGlvbnMob3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnMpIHtcbiAgICAgICAgLy89PiBVcGRhdGUgcHJvcGVydGllc1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vPT4gTWFyayBjaGFuZ2VkIHByb3BlcnRpZXMgYXMgdG91Y2hlZFxuICAgICAgICBjb25zdCB0b3VjaGVkS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpIGFzIEFycmF5PGtleW9mIFN3ZWV0QWxlcnRPcHRpb25zPjtcbiAgICAgICAgdG91Y2hlZEtleXMuZm9yRWFjaCh0aGlzLm1hcmtUb3VjaGVkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgb3B0aW9ucyBvYmplY3QgdGhhdCB3aWxsIGdldCBwYXNzZWQgdG8gU3dlZXRBbGVydDIuXG4gICAgICogT25seSB0aGUgcHJvcGVydGllcyB0aGF0IGhhdmUgYmVlbiBzZXQgYXQgbGVhc3Qgb25jZSBvbiB0aGlzIGNvbXBvbmVudCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIE1vc3RseSBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gICAgICovXG4gICAgcHVibGljIGdldCBzd2FsT3B0aW9ucygpOiBTd2VldEFsZXJ0T3B0aW9ucyB7XG4gICAgICAgIC8vPT4gV2Ugd2lsbCBjb21wdXRlIHRoZSBvcHRpb25zIG9iamVjdCBiYXNlZCBvbiB0aGUgb3B0aW9uIGtleXMgdGhhdCBhcmUga25vd24gdG8gaGF2ZSBjaGFuZ2VkLlxuICAgICAgICAvLyAgIFRoYXQgYXZvaWRzIHBhc3NpbmcgYSBnaWdhbnRpYyBvYmplY3QgdG8gU3dlZXRBbGVydDIsIG1ha2luZyBkZWJ1Z2dpbmcgZWFzaWVyIGFuZCBwb3RlbnRpYWxseVxuICAgICAgICAvLyAgIGF2b2lkaW5nIHNpZGUgZWZmZWN0cy5cbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnRvdWNoZWRQcm9wc10ucmVkdWNlPFN3ZWV0QWxlcnRPcHRpb25zPihcbiAgICAgICAgICAgIChvYmosIGtleSkgPT4gKHsgLi4ub2JqLCBba2V5XTogdGhpc1trZXkgYXMga2V5b2YgdGhpc10gfSksXG4gICAgICAgICAgICB7fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBmaXJlIHRoZSBtb2RhbCBhcyBzb29uIGFzIHRoZSA8c3dhbD4gY29tcG9uZW50IGlzIGNyZWF0ZWQgYW5kIGluaXRpYWxpemVkIGluIHRoZSB2aWV3LlxuICAgICAqIFdoZW4gbGVmdCB1bmRlZmluZWQgKGRlZmF1bHQpLCB0aGUgdmFsdWUgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgbW9kdWxlIGNvbmZpZ3VyYXRpb24sIHdoaWNoIGlzIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICA8c3dhbCAqbmdJZj1cImVycm9yXCIgW3RpdGxlXT1cImVycm9yLnRpdGxlXCIgW3RleHRdPVwiZXJyb3IudGV4dFwiIGljb249XCJlcnJvclwiIFtzd2FsRmlyZU9uSW5pdF09XCJ0cnVlXCI+PC9zd2FsPlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHN3YWxGaXJlT25Jbml0PzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZGlzbWlzcyB0aGUgbW9kYWwgd2hlbiB0aGUgPHN3YWw+IGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgYnkgQW5ndWxhciAoZm9yIGFueSByZWFzb24pIG9yIG5vdC5cbiAgICAgKiBXaGVuIGxlZnQgdW5kZWZpbmVkIChkZWZhdWx0KSwgdGhlIHZhbHVlIHdpbGwgYmUgaW5oZXJpdGVkIGZyb20gdGhlIG1vZHVsZSBjb25maWd1cmF0aW9uLCB3aGljaCBpcyBgdHJ1ZWAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3dhbERpc21pc3NPbkRlc3Ryb3k/OiBib29sZWFuO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IHN3YWxWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pIHtcbiAgICAgICAgdmlzaWJsZSA/IHRoaXMuZmlyZSgpIDogdGhpcy5jbG9zZSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgc3dhbFZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQ3VycmVudGx5U2hvd247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kYWwgbGlmZWN5Y2xlIGhvb2suIFN5bmNocm9ub3VzbHkgcnVucyBiZWZvcmUgdGhlIG1vZGFsIGlzIHNob3duIG9uIHNjcmVlbi5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgd2lsbE9wZW4gPSBuZXcgRXZlbnRFbWl0dGVyPGV2ZW50cy5XaWxsT3BlbkV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogTW9kYWwgbGlmZWN5Y2xlIGhvb2suIFN5bmNocm9ub3VzbHkgcnVucyBiZWZvcmUgdGhlIG1vZGFsIGlzIHNob3duIG9uIHNjcmVlbi5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGlkT3BlbiA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLkRpZE9wZW5FdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIE1vZGFsIGxpZmVjeWNsZSBob29rLiBTeW5jaHJvbm91c2x5IHJ1bnMgYWZ0ZXIgdGhlIHBvcHVwIERPTSBoYXMgYmVlbiB1cGRhdGVkIChpZS4ganVzdCBiZWZvcmUgdGhlIG1vZGFsIGlzXG4gICAgICogcmVwYWludGVkIG9uIHRoZSBzY3JlZW4pLlxuICAgICAqIFR5cGljYWxseSwgdGhpcyB3aWxsIGhhcHBlbiBhZnRlciBgU3dhbC5maXJlKClgIG9yIGBTd2FsLnVwZGF0ZSgpYC5cbiAgICAgKiBJZiB5b3Ugd2FudCB0byBwZXJmb3JtIGNoYW5nZXMgaW4gdGhlIHBvcHVwJ3MgRE9NLCB0aGF0IHN1cnZpdmUgYFN3YWwudXBkYXRlKClgLCBwcmVmZXIge0BsaW5rIGRpZFJlbmRlcn0gb3ZlclxuICAgICAqIHtAbGluayB3aWxsT3Blbn0uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGRpZFJlbmRlciA9IG5ldyBFdmVudEVtaXR0ZXI8ZXZlbnRzLkRpZFJlbmRlckV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICogTW9kYWwgbGlmZWN5Y2xlIGhvb2suIFN5bmNocm9ub3VzbHkgcnVucyB3aGVuIHRoZSBwb3B1cCBjbG9zZXMgYnkgdXNlciBpbnRlcmFjdGlvbiAoYW5kIG5vdCBkdWUgdG8gYW5vdGhlciBwb3B1cFxuICAgICAqIGJlaW5nIGZpcmVkKS5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgd2lsbENsb3NlID0gbmV3IEV2ZW50RW1pdHRlcjxldmVudHMuV2lsbENsb3NlRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBNb2RhbCBsaWZlY3ljbGUgaG9vay4gQXN5bmNocm9ub3VzbHkgcnVucyBhZnRlciB0aGUgcG9wdXAgaGFzIGJlZW4gZGlzcG9zZWQgYnkgdXNlciBpbnRlcmFjdGlvbiAoYW5kIG5vdCBkdWUgdG9cbiAgICAgKiBhbm90aGVyIHBvcHVwIGJlaW5nIGZpcmVkKS5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGlkQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBNb2RhbCBsaWZlY3ljbGUgaG9vay4gU3luY2hyb25vdXNseSBydW5zIGFmdGVyIHBvcHVwIGhhcyBiZWVuIGRlc3Ryb3llZCBlaXRoZXIgYnkgdXNlciBpbnRlcmFjdGlvbiBvciBieSBhbm90aGVyXG4gICAgICogcG9wdXAuXG4gICAgICogSWYgeW91IGhhdmUgY2xlYW51cCBvcGVyYXRpb25zIHRoYXQgeW91IG5lZWQgdG8gcmVsaWFibHkgZXhlY3V0ZSBlYWNoIHRpbWUgYSBtb2RhbCBpcyBjbG9zZWQsIHByZWZlclxuICAgICAqIHtAbGluayBkaWREZXN0cm95fSBvdmVyIHtAbGluayBkaWRDbG9zZX0uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGRpZERlc3Ryb3kgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNvbmZpcm1cIi5cbiAgICAgKiBUaGUgZXZlbnQgdmFsdWUgKCRldmVudCkgY2FuIGJlIGVpdGhlcjpcbiAgICAgKiAgLSBieSBkZWZhdWx0LCBqdXN0IGB0cnVlYCxcbiAgICAgKiAgLSB3aGVuIHVzaW5nIHtAbGluayBpbnB1dH0sIHRoZSBpbnB1dCB2YWx1ZSxcbiAgICAgKiAgLSB3aGVuIHVzaW5nIHtAbGluayBwcmVDb25maXJtfSwgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgPHN3YWwgKGNvbmZpcm0pPVwiaGFuZGxlQ29uZmlybSgkZXZlbnQpXCI+PC9zd2FsPlxuICAgICAqXG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVDb25maXJtKGVtYWlsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIC4uLiBzYXZlIHVzZXIgZW1haWxcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBjb25maXJtID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkRlbnlcIi5cbiAgICAgKiBUaGlzIGV2ZW50IGJlYXJzIG5vIHZhbHVlLlxuICAgICAqIFVzZSBgKGRlbnkpYCAoYWxvbmcgd2l0aCB7QGxpbmsgc2hvd0RlbnlCdXR0b259KSB3aGVuIHlvdSB3YW50IGEgbW9kYWwgd2l0aCB0aHJlZSBidXR0b25zIChjb25maXJtLCBkZW55IGFuZFxuICAgICAqIGNhbmNlbCksIGFuZC9vciB3aGVuIHlvdSB3YW50IHRvIGhhbmRsZSBjbGVhciByZWZ1c2FsIGluIGEgc2VwYXJhdGUgd2F5IHRoYW4gc2ltcGxlIGRpc21pc3NhbC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIDxzd2FsIChkZW55KT1cImhhbmRsZURlbnkoKVwiPjwvc3dhbD5cbiAgICAgKlxuICAgICAqICAgICBwdWJsaWMgaGFuZGxlRGVueSgpOiB2b2lkIHtcbiAgICAgKiAgICAgfVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBkZW55ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aGUgdXNlciBjbGlja3MgXCJDYW5jZWxcIiwgb3IgZGlzbWlzc2VzIHRoZSBtb2RhbCBieSBhbnkgb3RoZXIgYWxsb3dlZCB3YXkuXG4gICAgICogVGhlIGV2ZW50IHZhbHVlICgkZXZlbnQpIGlzIGEgc3RyaW5nIHRoYXQgZXhwbGFpbnMgaG93IHRoZSBtb2RhbCB3YXMgZGlzbWlzc2VkLiBJdCBpcyBgdW5kZWZpbmVkYCB3aGVuXG4gICAgICogdGhlIG1vZGFsIHdhcyBwcm9ncmFtbWF0aWNhbGx5IGNsb3NlZCAodGhyb3VnaCB7QGxpbmsgY2xvc2V9IGZvciBleGFtcGxlKS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogICAgIDxzd2FsIChkaXNtaXNzKT1cImhhbmRsZURpc21pc3MoJGV2ZW50KVwiPjwvc3dhbD5cbiAgICAgKlxuICAgICAqICAgICBwdWJsaWMgaGFuZGxlRGlzbWlzcyhyZWFzb246IERpc21pc3NSZWFzb24gfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICAgKiAgICAgICAgIC8vIHJlYXNvbiBjYW4gYmUgJ2NhbmNlbCcsICdvdmVybGF5JywgJ2Nsb3NlJywgJ3RpbWVyJyBvciB1bmRlZmluZWQuXG4gICAgICogICAgICAgICAvLyAuLi4gZG8gc29tZXRoaW5nXG4gICAgICogICAgIH1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGlzbWlzcyA9IG5ldyBFdmVudEVtaXR0ZXI8U3dhbC5EaXNtaXNzUmVhc29uIHwgdW5kZWZpbmVkPigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBTZXQgcmV0YWlucyB0aGUgcHJvcGVydGllcyB0aGF0IGhhdmUgYmVlbiBjaGFuZ2VkIGZyb20gQElucHV0cywgc28gd2UgY2FuIGtub3cgcHJlY2lzZWx5XG4gICAgICogd2hhdCBvcHRpb25zIHdlIGhhdmUgdG8gc2VuZCB0byB7QGxpbmsgU3dhbC5maXJlfS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IHRvdWNoZWRQcm9wcyA9IG5ldyBTZXQ8a2V5b2YgU3dlZXRBbGVydE9wdGlvbnM+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIG9mIHNpZ25hdHVyZSBgKHByb3BOYW1lOiBzdHJpbmcpOiB2b2lkYCB0aGF0IGFkZHMgYSBnaXZlbiBwcm9wZXJ0eSBuYW1lIHRvIHRoZSBsaXN0IG9mXG4gICAgICogdG91Y2hlZCBwcm9wZXJ0aWVzLCBpZS4ge0BsaW5rIHRvdWNoZWRQcm9wc30uXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWFkb25seSBtYXJrVG91Y2hlZCA9IHRoaXMudG91Y2hlZFByb3BzLmFkZC5iaW5kKHRoaXMudG91Y2hlZFByb3BzKTtcblxuICAgIC8qKlxuICAgICAqIElzIHRoZSBTd2VldEFsZXJ0MiBtb2RhbCByZXByZXNlbnRlZCBieSB0aGlzIGNvbXBvbmVudCBjdXJyZW50bHkgb3BlbmVkP1xuICAgICAqL1xuICAgIHByaXZhdGUgaXNDdXJyZW50bHlTaG93biA9IGZhbHNlO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHN3ZWV0QWxlcnQyTG9hZGVyOiBTd2VldEFsZXJ0MkxvYWRlclNlcnZpY2UsXG4gICAgICAgIEBJbmplY3QoZmlyZU9uSW5pdFRva2VuKSBwcml2YXRlIHJlYWRvbmx5IG1vZHVsZUxldmVsRmlyZU9uSW5pdDogYm9vbGVhbixcbiAgICAgICAgQEluamVjdChkaXNtaXNzT25EZXN0cm95VG9rZW4pIHByaXZhdGUgcmVhZG9ubHkgbW9kdWxlTGV2ZWxEaXNtaXNzT25EZXN0cm95OiBib29sZWFuKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBsaWZlY3ljbGUgaG9vay5cbiAgICAgKiBBc2tzIHRoZSBTd2VldEFsZXJ0MiBsb2FkZXIgc2VydmljZSB0byBwcmVsb2FkIHRoZSBTd2VldEFsZXJ0MiBsaWJyYXJ5LCBzbyBpdCBiZWdpbnMgdG8gYmUgbG9hZGVkIG9ubHkgaWYgdGhlcmVcbiAgICAgKiBpcyBhIDxzd2FsPiBjb21wb25lbnQgc29tZXdoZXJlLCBhbmQgaXMgcHJvYmFibHkgZnVsbHkgbG9hZGVkIHdoZW4gdGhlIG1vZGFsIGhhcyB0byBiZSBkaXNwbGF5ZWQsXG4gICAgICogY2F1c2luZyBubyBkZWxheS5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIC8vPT4gUHJlbG9hZCBTd2VldEFsZXJ0MiBsaWJyYXJ5IGluIGNhc2UgdGhpcyBjb21wb25lbnQgaXMgYWN0aXZhdGVkLlxuICAgICAgICB0aGlzLnN3ZWV0QWxlcnQyTG9hZGVyLnByZWxvYWRTd2VldEFsZXJ0TGlicmFyeSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgbGlmZWN5Y2xlIGhvb2suXG4gICAgICogRmlyZXMgdGhlIG1vZGFsLCBpZiB0aGUgY29tcG9uZW50IG9yIG1vZHVsZSBpcyBjb25maWd1cmVkIHRvIGRvIHNvLlxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGZpcmVPbkluaXQgPSB0aGlzLnN3YWxGaXJlT25Jbml0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdGhpcy5tb2R1bGVMZXZlbEZpcmVPbkluaXRcbiAgICAgICAgICAgIDogdGhpcy5zd2FsRmlyZU9uSW5pdDtcblxuICAgICAgICBmaXJlT25Jbml0ICYmIHRoaXMuZmlyZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgbGlmZWN5Y2xlIGhvb2suXG4gICAgICogVXBkYXRlcyB0aGUgU3dlZXRBbGVydCBvcHRpb25zLCBhbmQgaWYgdGhlIG1vZGFsIGlzIG9wZW5lZCwgYXNrcyBTd2VldEFsZXJ0IHRvIHJlbmRlciBpdCBhZ2Fpbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgICAgICAvLz0+IEZvciBlYWNoIGNoYW5nZWQgQElucHV0IHRoYXQgbWF0Y2hlcyBhIFN3ZWV0QWxlcnQyIG9wdGlvbiwgbWFyayBhcyB0b3VjaGVkIHNvIHdlIGNhblxuICAgICAgICAvLyAgIHNlbmQgaXQgd2l0aCB0aGUgbmV4dCBmaXJlKCkgb3IgdXBkYXRlKCkgY2FsbHMuXG4gICAgICAgIE9iamVjdC5rZXlzKGNoYW5nZXMpXG4gICAgICAgICAgICAvLz0+IElmIHRoZSBmaWx0ZXJpbmcgbG9naWMgYmVjb21lcyBtb3JlIGNvbXBsZXggaGVyZSwgd2UgY2FuIHVzZSBTd2FsLmlzVmFsaWRQYXJhbWV0ZXJcbiAgICAgICAgICAgIC5maWx0ZXIoKGtleSk6IGtleSBpcyBrZXlvZiBTd2VldEFsZXJ0T3B0aW9ucyA9PiAha2V5LnN0YXJ0c1dpdGgoJ3N3YWwnKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKHRoaXMubWFya1RvdWNoZWQpO1xuXG4gICAgICAgIC8vPT4gRXZlbnR1YWxseSB0cmlnZ2VyIHJlLXJlbmRlciBpZiB0aGUgbW9kYWwgaXMgb3Blbi5cbiAgICAgICAgdm9pZCB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgbGlmZWN5Y2xlIGhvb2suXG4gICAgICogQ2xvc2VzIHRoZSBTd2VldEFsZXJ0IHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAvLz0+IFJlbGVhc2UgdGhlIG1vZGFsIGlmIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGFuZCBpZiB0aGF0IGJlaGF2aW91ciBpcyBub3QgZGlzYWJsZWQuXG4gICAgICAgIGNvbnN0IGRpc21pc3NPbkRlc3Ryb3kgPSB0aGlzLnN3YWxEaXNtaXNzT25EZXN0cm95ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdGhpcy5tb2R1bGVMZXZlbERpc21pc3NPbkRlc3Ryb3lcbiAgICAgICAgICAgIDogdGhpcy5zd2FsRGlzbWlzc09uRGVzdHJveTtcblxuICAgICAgICBkaXNtaXNzT25EZXN0cm95ICYmIHRoaXMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgU3dlZXRBbGVydC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIFN3ZWV0QWxlcnQyIHByb21pc2UgZm9yIGNvbnZlbmllbmNlIGFuZCB1c2UgaW4gY29kZSBiZWhpbmQgdGVtcGxhdGVzLlxuICAgICAqIE90aGVyd2lzZSwgKGNvbmZpcm0pPVwibXlIYW5kbGVyKCRldmVudClcIiBhbmQgKGRpc21pc3MpPVwibXlIYW5kbGVyKCRldmVudClcIiBjYW4gYmUgdXNlZCBpbiB0ZW1wbGF0ZXMuXG4gICAgICovXG4gICAgcHVibGljIGFzeW5jIGZpcmUoKTogUHJvbWlzZTxTd2VldEFsZXJ0UmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IHN3YWwgPSBhd2FpdCB0aGlzLnN3ZWV0QWxlcnQyTG9hZGVyLnN3YWw7XG5cbiAgICAgICAgY29uc3QgdXNlck9wdGlvbnMgPSB0aGlzLnN3YWxPcHRpb25zO1xuXG4gICAgICAgIC8vPT4gQnVpbGQgdGhlIFN3ZWV0QWxlcnQyIG9wdGlvbnNcbiAgICAgICAgY29uc3Qgb3B0aW9uczogU3dlZXRBbGVydE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAvLz0+IE1lcmdlIHdpdGggY2FsY3VsYXRlZCBvcHRpb25zIHNldCBmb3IgdGhhdCBzcGVjaWZpYyBzd2FsXG4gICAgICAgICAgICAuLi51c2VyT3B0aW9ucyxcblxuICAgICAgICAgICAgLy89PiBIYW5kbGUgbW9kYWwgbGlmZWN5Y2xlIGV2ZW50c1xuICAgICAgICAgICAgd2lsbE9wZW46IGNvbXBvc2VIb29rKHVzZXJPcHRpb25zLndpbGxPcGVuLCAobW9kYWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWxsT3Blbi5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkaWRPcGVuOiBjb21wb3NlSG9vayh1c2VyT3B0aW9ucy5kaWRPcGVuLCAobW9kYWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0N1cnJlbnRseVNob3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpZE9wZW4uZW1pdCh7IG1vZGFsRWxlbWVudCB9KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGlkUmVuZGVyOiBjb21wb3NlSG9vayh1c2VyT3B0aW9ucy5kaWRSZW5kZXIsIChtb2RhbEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpZFJlbmRlci5lbWl0KHsgbW9kYWxFbGVtZW50IH0pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3aWxsQ2xvc2U6IGNvbXBvc2VIb29rKHVzZXJPcHRpb25zLndpbGxDbG9zZSwgKG1vZGFsRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDdXJyZW50bHlTaG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMud2lsbENsb3NlLmVtaXQoeyBtb2RhbEVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGRpZENsb3NlOiBjb21wb3NlSG9vayh1c2VyT3B0aW9ucy5kaWRDbG9zZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlkQ2xvc2UuZW1pdCgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkaWREZXN0cm95OiBjb21wb3NlSG9vayh1c2VyT3B0aW9ucy5kaWREZXN0cm95LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWREZXN0cm95LmVtaXQoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG5cbiAgICAgICAgLy89PiBTaG93IHRoZSBTd2FsISBBbmQgd2FpdCBmb3IgY29uZmlybWF0aW9uIG9yIGRpbWlzc2FsLlxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzd2FsLmZpcmUob3B0aW9ucyk7XG5cbiAgICAgICAgLy89PiBFbWl0IG9uIChjb25maXJtKSwgKGRlbnkpIG9yIChkaXNtaXNzKVxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgcmVzdWx0LmlzQ29uZmlybWVkOiB0aGlzLmNvbmZpcm0uZW1pdChyZXN1bHQudmFsdWUpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcmVzdWx0LmlzRGVuaWVkOiB0aGlzLmRlbnkuZW1pdCgpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcmVzdWx0LmlzRGlzbWlzc2VkOiB0aGlzLmRpc21pc3MuZW1pdChyZXN1bHQuZGlzbWlzcyk7IGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBmdW5jdGlvbiBjb21wb3NlSG9vazxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPihcbiAgICAgICAgICAgIHVzZXJIb29rOiBUIHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGliSG9vazogVCk6ICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB2b2lkIHtcblxuICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiAobGliSG9vayguLi5hcmdzKSwgdXNlckhvb2s/LiguLi5hcmdzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIG1vZGFsLCBpZiBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVzdWx0IFRoZSB2YWx1ZSB0aGF0IHRoZSBtb2RhbCB3aWxsIHJlc29sdmUgd2l0aCwgdHJpZ2dlcmluZyBlaXRoZXIgKGNvbmZpcm0pLCAoZGVueSkgb3IgKGRpc21pc3MpLlxuICAgICAqICAgICAgICAgICAgICAgSWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBwYXNzZWQsIGl0IGlzIChkaXNtaXNzKSB0aGF0IHdpbGwgZW1pdCBhbiBgdW5kZWZpbmVkYCByZWFzb24uXG4gICAgICogICAgICAgICAgICAgICB7QHNlZSBTd2FsLmNsb3NlfS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgY2xvc2UocmVzdWx0PzogU3dlZXRBbGVydFJlc3VsdCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAoIXRoaXMuaXNDdXJyZW50bHlTaG93bikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IHN3YWwgPSBhd2FpdCB0aGlzLnN3ZWV0QWxlcnQyTG9hZGVyLnN3YWw7XG4gICAgICAgIHN3YWwuY2xvc2UocmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIFN3ZWV0QWxlcnQyIG9wdGlvbnMgd2hpbGUgdGhlIG1vZGFsIGlzIG9wZW5lZCwgY2F1c2luZyB0aGUgbW9kYWwgdG8gcmUtcmVuZGVyLlxuICAgICAqIElmIHRoZSBtb2RhbCBpcyBub3Qgb3BlbmVkLCB0aGUgY29tcG9uZW50IG9wdGlvbnMgd2lsbCBzaW1wbHkgYmUgdXBkYXRlZCBhbmQgdGhhdCdzIGl0LlxuICAgICAqXG4gICAgICogLyFcXCBQbGVhc2Ugbm90ZSB0aGF0IG5vdCBhbGwgU3dlZXRBbGVydDIgb3B0aW9ucyBhcmUgdXBkYXRhYmxlIHdoaWxlIHRoZSBtb2RhbCBpcyBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyB1cGRhdGUob3B0aW9ucz86IFBpY2s8U3dlZXRBbGVydE9wdGlvbnMsIFN3ZWV0QWxlcnRVcGRhdGFibGVQYXJhbWV0ZXJzPik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zd2FsT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNDdXJyZW50bHlTaG93bikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IHN3YWwgPSBhd2FpdCB0aGlzLnN3ZWV0QWxlcnQyTG9hZGVyLnN3YWw7XG5cbiAgICAgICAgY29uc3QgYWxsT3B0aW9ucyA9IHRoaXMuc3dhbE9wdGlvbnM7XG5cbiAgICAgICAgY29uc3QgdXBkYXRhYmxlT3B0aW9ucyA9IE9iamVjdC5rZXlzKGFsbE9wdGlvbnMpXG4gICAgICAgICAgICAuZmlsdGVyKHN3YWwuaXNVcGRhdGFibGVQYXJhbWV0ZXIpXG4gICAgICAgICAgICAucmVkdWNlPFBpY2s8U3dlZXRBbGVydE9wdGlvbnMsIFN3ZWV0QWxlcnRVcGRhdGFibGVQYXJhbWV0ZXJzPj4oXG4gICAgICAgICAgICAgICAgKG9iaiwga2V5KSA9PiAoeyAuLi5vYmosIFtrZXldOiBhbGxPcHRpb25zW2tleV0gfSksXG4gICAgICAgICAgICAgICAge30pO1xuXG4gICAgICAgIHN3YWwudXBkYXRlKHVwZGF0YWJsZU9wdGlvbnMpO1xuICAgIH1cbn1cbiJdfQ==